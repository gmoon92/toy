package com.gmoon.dbrecovery.global.recovery.datasource;

import com.gmoon.javacore.util.CollectionUtils;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Delegate;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.update.Update;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@RequiredArgsConstructor
public class DataSourceProxy implements DataSource, RedefineDataSource {

	public static final ThreadLocal<Connection> connectionThreadLocal = new ThreadLocal<>();
	public static final ThreadLocal<Map<Class<? extends Statement>, Set<String>>> detectedStatementThreadLocal = ThreadLocal.withInitial(ConcurrentHashMap::new);

	@Delegate(excludes = RedefineDataSource.class)
	private final DataSource dataSource;

	@Override
	public Connection getConnection() throws SQLException {
		Connection connection = dataSource.getConnection();
		return new ConnectionProxy(connection);
	}

	@Override
	public Connection getConnection(String username, String password) throws SQLException {
		Connection connection = dataSource.getConnection(username, password);
		return new ConnectionProxy(connection);
	}

	@RequiredArgsConstructor
	static class ConnectionProxy implements Connection, RedefineConnection {

		@Delegate(excludes = RedefineConnection.class)
		private final Connection connection;

		@Override
		public PreparedStatement prepareStatement(String sql) throws SQLException {
			detectModifiedTables(sql);
			return connection.prepareStatement(sql);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
			detectModifiedTables(sql);
			return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
			detectModifiedTables(sql);
			return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
			detectModifiedTables(sql);
			return connection.prepareStatement(sql, autoGeneratedKeys);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
			detectModifiedTables(sql);
			return connection.prepareStatement(sql, columnIndexes);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
			detectModifiedTables(sql);
			return connection.prepareStatement(sql, columnNames);
		}

		private void detectModifiedTables(String sql) {
			try {
				connectionThreadLocal.set(this);
				Statement statement = CCJSqlParserUtil.parse(sql);
				if (statement instanceof Insert
					 || statement instanceof Update
					 || statement instanceof Delete
				) {
					// todo check table on cacecade delete option
					Table table = getDectedTable(statement);
					String tableName = table.getName();
					storeDetectedTable(statement.getClass(), tableName);
					log.info("[DETECTED]   {}", table.getName(), sql);
				} else {
					log.info("[UNDETECTED] {}", sql);
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}

		private void storeDetectedTable(Class<? extends Statement> key, String tableName) {
			Map<Class<? extends Statement>, Set<String>> modifiedTables = detectedStatementThreadLocal.get();
			Set<String> tables = modifiedTables.get(key);
			if (CollectionUtils.isEmpty(tables)) {
				tables = new HashSet<>();
			}
			tables.add(tableName);
			modifiedTables.put(key, tables);
		}

		private Table getDectedTable(Statement statement) {
			if (statement instanceof Delete) {
				return ( (Delete) statement ).getTable();
			} else if (statement instanceof Update) {
				return ( (Update) statement ).getTable();
			} else if (statement instanceof Insert) {
				return ( (Insert) statement ).getTable();
			}
			throw new IllegalArgumentException("Not detected statement.");
		}

	}
}
