package com.gmoon.dbrecovery.global.persistence.datasource;

import com.gmoon.javacore.util.CollectionUtils;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Delegate;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.update.Update;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Slf4j
@RequiredArgsConstructor
public class DataSourceProxy implements DataSource, RedefineDataSource {

	public static Map<Class<? extends Statement>, Set<String>> MODIFIED_TABLES = new HashMap<>();

	@Delegate(excludes = RedefineDataSource.class)
	private final DataSource dataSource;

	@RequiredArgsConstructor
	static class ConnectionProxy implements Connection, RedefineConnection {

		@Delegate(excludes = RedefineConnection.class)
		private final Connection connection;

		@Override
		public PreparedStatement prepareStatement(String sql) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, autoGeneratedKeys);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, columnIndexes);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, columnNames);
		}

		private void detect(String sql) {
			try {
				// todo proxy jdbc driver crud query detected.
				Statement parse = CCJSqlParserUtil.parse(sql);
				if (parse instanceof Insert) {
					Table table = ( (Insert) parse ).getTable();
					String tableName = table.getName();
					putModifiedTables(Insert.class, tableName);
					log.info("[INSERT {}] {}", tableName, sql);
				} else if (parse instanceof Update) {
					Table table = ( (Update) parse ).getTable();
					String tableName = table.getName();
					putModifiedTables(Update.class, tableName);
					log.info("[UPDATE {}] {}", tableName, sql);
				} else if (parse instanceof Delete) {
					// todo check table on cacecade delete option
					Table table = ( (Delete) parse ).getTable();
					String tableName = table.getName();
					putModifiedTables(Delete.class, tableName);
					log.info("[DELETE {}] {}", table.getName(), sql);
				} else {
					log.info("[UNDETECTED] {}", sql);
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}

		private void putModifiedTables(Class<? extends Statement> key, String tableName) {
			Set<String> tables = MODIFIED_TABLES.get(key);
			if (CollectionUtils.isEmpty(tables)) {
				tables = new HashSet<>();
				MODIFIED_TABLES.put(key, tables);
			}
			tables.add(tableName);
		}

	}

	@Override
	public Connection getConnection() throws SQLException {
		Connection connection = dataSource.getConnection();
		return new ConnectionProxy(connection);
	}

	@Override
	public Connection getConnection(String username, String password) throws SQLException {
		Connection connection = dataSource.getConnection(username, password);
		return new ConnectionProxy(connection);
	}
}
