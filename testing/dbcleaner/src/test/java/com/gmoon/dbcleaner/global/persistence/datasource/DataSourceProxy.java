package com.gmoon.dbcleaner.global.persistence.datasource;

import lombok.RequiredArgsConstructor;
import lombok.experimental.Delegate;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.select.Select;
import net.sf.jsqlparser.statement.update.Update;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

@Slf4j
@RequiredArgsConstructor
public class DataSourceProxy implements DataSource, RedefineDataSource {

	@Delegate(excludes = RedefineDataSource.class)
	private final DataSource dataSource;

	@RequiredArgsConstructor
	static class ConnectionProxy implements Connection, RedefineConnection {

		@Delegate(excludes = RedefineConnection.class)
		private final Connection connection;

		@Override
		public PreparedStatement prepareStatement(String sql) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, autoGeneratedKeys);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, columnIndexes);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
			detect(sql);
			return connection.prepareStatement(sql, columnNames);
		}

		private void detect(String sql) {
//			log.info("query {}", sql); // todo check

			try {
				// todo proxy jdbc driver crud query detected.
				Statement parse = CCJSqlParserUtil.parse(sql);
				if (parse instanceof Select) {
					log.info("[SELECT query] {}", sql);
				}
				if (parse instanceof Insert) {
					Table table = ( (Insert) parse ).getTable();
					log.info("[INSERT {}] {}", table.getName(), sql);
				}
				if (parse instanceof Update) {
					Table table = ( (Update) parse ).getTable();
					log.info("[UPDATE {}] {}", table.getName(), sql);
				}
				if (parse instanceof Delete) {
					Table table = ( (Delete) parse ).getTable();
					log.info("[DELETE {}] {}", table.getName(), sql);
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}

	}

	@Override
	public Connection getConnection() throws SQLException {
		Connection connection = dataSource.getConnection();
		return new ConnectionProxy(connection);
	}

	@Override
	public Connection getConnection(String username, String password) throws SQLException {
		Connection connection = dataSource.getConnection(username, password);
		return new ConnectionProxy(connection);
	}
}
