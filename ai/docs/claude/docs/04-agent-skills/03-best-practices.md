# [Skill 작성 모범 사례](https://platform.claude.com/docs/en/agents-and-tools/agent-skills/best-practices)

Claude가 성공적으로 발견하고 사용할 수 있는 효과적인 Skill을 작성하는 방법을 알아봅니다.

---

좋은 Skill은 간결하고 잘 구조화되어 있으며, 실제 사용 사례로 테스트되었습니다. 이 가이드는 Claude가 효과적으로 발견하고 사용할 수 있는 Skill을 작성하는 데 도움이 되는 실용적인 작성 지침을 제공합니다.

Skill의 작동 방식에 대한 개념적 배경은 [Skills 개요](../04-agent-skills/01-overview.md)를 참조하세요.

## 핵심 원칙

### 간결함이 핵심입니다

[컨텍스트 윈도우](../01-build-with-claude/02-context-windows.md)는 공공재입니다. 여러분의 Skill은 Claude가 알아야 하는 다른 모든 것들과 컨텍스트 윈도우를 공유합니다:
- 시스템 프롬프트
- 대화 기록
- 다른 Skill들의 메타데이터
- 실제 요청 내용

Skill의 모든 토큰에 즉각적인 비용이 드는 것은 아닙니다. 시작 시점에는 모든 Skill의 메타데이터(이름과 설명)만 사전 로드됩니다. Claude는 Skill이 관련성이 있을 때만 SKILL.md를 읽고, 필요할 때만 추가 파일을 읽습니다. 그러나 SKILL.md에서 간결함을 유지하는 것은 여전히 중요합니다. Claude가 파일을 로드하면 모든 토큰이 대화 기록 및 다른 컨텍스트와 경쟁하기 때문입니다.

**기본 가정**: Claude는 이미 매우 똑똑합니다

Claude가 이미 가지고 있지 않은 컨텍스트만 추가하세요. 각 정보에 대해 질문하세요:
- "Claude가 정말로 이 설명이 필요한가?"
- "Claude가 이것을 알고 있다고 가정할 수 있는가?"
- "이 문단이 토큰 비용을 정당화하는가?"

**좋은 예: 간결함** (약 50 토큰):
````markdown
## PDF 텍스트 추출

텍스트 추출에는 pdfplumber를 사용하세요:

```python
import pdfplumber

with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
```
````

**나쁜 예: 너무 장황함** (약 150 토큰):
```markdown
## PDF 텍스트 추출

PDF(Portable Document Format) 파일은 텍스트, 이미지 및 기타 콘텐츠를 포함하는 일반적인 파일 형식입니다. PDF에서 텍스트를 추출하려면 라이브러리를 사용해야 합니다. PDF 처리에 사용할 수 있는 라이브러리가 많이 있지만, 사용하기 쉽고 대부분의 경우를 잘 처리하기 때문에 pdfplumber를 권장합니다.
먼저 pip을 사용하여 설치해야 합니다. 그런 다음 아래 코드를 사용할 수 있습니다...
```

간결한 버전은 Claude가 PDF가 무엇인지, 라이브러리가 어떻게 작동하는지 알고 있다고 가정합니다.

### 적절한 자유도 설정

작업의 취약성과 가변성에 맞춰 구체성 수준을 조정하세요.

**높은 자유도** (텍스트 기반 지침):

다음과 같은 경우 사용:
- 여러 접근 방식이 유효한 경우
- 결정이 컨텍스트에 따라 달라지는 경우
- 휴리스틱이 접근 방식을 안내하는 경우

예시:
```markdown
## 코드 리뷰 프로세스

1. 코드 구조와 조직 분석
2. 잠재적 버그나 엣지 케이스 확인
3. 가독성과 유지보수성 개선 제안
4. 프로젝트 규칙 준수 확인
```

**중간 자유도** (매개변수가 있는 의사 코드 또는 스크립트):

다음과 같은 경우 사용:
- 선호하는 패턴이 있는 경우
- 약간의 변형이 허용되는 경우
- 구성이 동작에 영향을 미치는 경우

예시:
````markdown
## 보고서 생성

이 템플릿을 사용하고 필요에 따라 사용자 정의하세요:

```python
def generate_report(data, format="markdown", include_charts=True):
    # 데이터 처리
    # 지정된 형식으로 출력 생성
    # 선택적으로 시각화 포함
```
````

**낮은 자유도** (특정 스크립트, 매개변수가 거의 없거나 전혀 없음):

다음과 같은 경우 사용:
- 작업이 취약하고 오류가 발생하기 쉬운 경우
- 일관성이 중요한 경우
- 특정 순서를 따라야 하는 경우

예시:
````markdown
## 데이터베이스 마이그레이션

정확히 이 스크립트를 실행하세요:

```bash
python scripts/migrate.py --verify --backup
```

명령을 수정하거나 추가 플래그를 추가하지 마세요.
````

**비유**: Claude를 길을 탐색하는 로봇으로 생각해보세요:
- **양쪽에 절벽이 있는 좁은 다리**: 앞으로 나아가는 안전한 방법은 하나뿐입니다. 구체적인 가드레일과 정확한 지침을 제공하세요(낮은 자유도). 예시: 정확한 순서로 실행해야 하는 데이터베이스 마이그레이션.
- **장애물이 없는 넓은 들판**: 많은 경로가 성공으로 이어집니다. 일반적인 방향을 제시하고 Claude가 최적의 경로를 찾도록 신뢰하세요(높은 자유도). 예시: 컨텍스트가 최선의 접근 방식을 결정하는 코드 리뷰.

### 사용하려는 모든 모델로 테스트

Skill은 모델에 대한 추가 기능으로 작동하므로 효과는 기본 모델에 따라 달라집니다. 사용하려는 모든 모델로 Skill을 테스트하세요.

**모델별 테스트 고려사항**:
- **Claude Haiku** (빠르고 경제적): Skill이 충분한 가이드를 제공하나요?
- **Claude Sonnet** (균형): Skill이 명확하고 효율적인가요?
- **Claude Opus** (강력한 추론): Skill이 과도하게 설명하지 않나요?

Opus에서 완벽하게 작동하는 것이 Haiku에서는 더 많은 세부 정보가 필요할 수 있습니다. 여러 모델에서 Skill을 사용할 계획이라면 모든 모델에서 잘 작동하는 지침을 목표로 하세요.

## Skill 구조


> **YAML Frontmatter**: SKILL.md frontmatter는 두 개의 필드가 필요합니다:
>
> `name`:
> - 최대 64자
> - 소문자, 숫자, 하이픈만 포함해야 함
> - XML 태그를 포함할 수 없음
> - 예약어를 포함할 수 없음: "anthropic", "claude"
>
> `description`:
> - 비어 있으면 안 됨
> - 최대 1024자
> - XML 태그를 포함할 수 없음
> - Skill이 무엇을 하는지, 언제 사용하는지 설명해야 함
>
> 전체 Skill 구조에 대한 자세한 내용은 [Skills 개요](../04-agent-skills/01-overview.md)를 참조하세요.


### 명명 규칙

일관된 명명 패턴을 사용하면 Skill을 더 쉽게 참조하고 논의할 수 있습니다. Skill 이름에는 **동명사 형태**(동사 + -ing)를 사용하는 것을 권장합니다. 이렇게 하면 Skill이 제공하는 활동이나 기능을 명확하게 설명할 수 있습니다.

`name` 필드는 소문자, 숫자, 하이픈만 사용해야 한다는 점을 기억하세요.

**좋은 명명 예시 (동명사 형태)**:
- `processing-pdfs`
- `analyzing-spreadsheets`
- `managing-databases`
- `testing-code`
- `writing-documentation`

**허용되는 대안**:
- 명사구: `pdf-processing`, `spreadsheet-analysis`
- 행동 지향: `process-pdfs`, `analyze-spreadsheets`

**피해야 할 것**:
- 모호한 이름: `helper`, `utils`, `tools`
- 지나치게 일반적: `documents`, `data`, `files`
- 예약어: `anthropic-helper`, `claude-tools`
- Skill 컬렉션 내에서 일관성 없는 패턴

일관된 명명은 다음을 쉽게 만듭니다:
- 문서와 대화에서 Skill 참조
- 한눈에 Skill이 무엇을 하는지 이해
- 여러 Skill을 구성하고 검색
- 전문적이고 일관된 Skill 라이브러리 유지

### 효과적인 설명 작성

`description` 필드는 Skill 발견을 가능하게 하며, Skill이 무엇을 하는지와 언제 사용하는지를 모두 포함해야 합니다.


> **항상 3인칭으로 작성하세요**. 설명은 시스템 프롬프트에 삽입되며, 일관성 없는 시점은 발견 문제를 일으킬 수 있습니다.
>
> - **좋음:** "Excel 파일을 처리하고 보고서를 생성합니다"
> - **피해야 함:** "Excel 파일 처리를 도와드릴 수 있습니다"
> - **피해야 함:** "Excel 파일을 처리하는 데 사용할 수 있습니다"


**구체적이고 핵심 용어를 포함하세요**. Skill이 무엇을 하는지와 언제 사용하는지에 대한 구체적인 트리거/컨텍스트를 모두 포함하세요.

각 Skill에는 정확히 하나의 description 필드가 있습니다. 설명은 Skill 선택에 매우 중요합니다. Claude는 이를 사용하여 잠재적으로 100개 이상의 사용 가능한 Skill 중에서 올바른 Skill을 선택합니다. 설명은 Claude가 이 Skill을 선택할 시기를 알 수 있도록 충분한 세부 정보를 제공해야 하며, SKILL.md의 나머지 부분은 구현 세부 정보를 제공합니다.

효과적인 예시:

**PDF 처리 Skill:**
```yaml
description: PDF 파일에서 텍스트와 표를 추출하고, 양식을 채우고, 문서를 병합합니다. PDF 파일로 작업하거나 사용자가 PDF, 양식 또는 문서 추출을 언급할 때 사용합니다.
```

**Excel 분석 Skill:**
```yaml
description: Excel 스프레드시트를 분석하고, 피벗 테이블을 생성하고, 차트를 만듭니다. Excel 파일, 스프레드시트, 표 형식 데이터 또는 .xlsx 파일을 분석할 때 사용합니다.
```

**Git Commit Helper Skill:**
```yaml
description: git diff를 분석하여 설명적인 커밋 메시지를 생성합니다. 사용자가 커밋 메시지 작성 또는 스테이징된 변경 사항 검토에 대한 도움을 요청할 때 사용합니다.
```

다음과 같은 모호한 설명은 피하세요:

```yaml
description: 문서를 돕습니다
```
```yaml
description: 데이터를 처리합니다
```
```yaml
description: 파일로 작업을 수행합니다
```

### 점진적 공개 패턴

SKILL.md는 필요에 따라 Claude가 상세한 자료를 참조할 수 있도록 하는 개요 역할을 하며, 온보딩 가이드의 목차와 같습니다. 점진적 공개가 어떻게 작동하는지에 대한 설명은 개요의 [How Skills work](../04-agent-skills/01-overview.md)를 참조하세요.

**실용적인 가이드:**
- 최적의 성능을 위해 SKILL.md 본문을 500줄 이하로 유지
- 이 제한에 가까워지면 콘텐츠를 별도 파일로 분할
- 지침, 코드 및 리소스를 효과적으로 구성하기 위해 아래 패턴 사용

#### 시각적 개요: 단순함에서 복잡함으로

기본 Skill은 메타데이터와 지침을 포함하는 SKILL.md 파일만으로 시작합니다:

![간단한 SKILL.md 파일 - YAML frontmatter와 마크다운 본문 표시](/docs/images/agent-skills-simple-file.png)

Skill이 커지면 필요할 때만 Claude가 로드하는 추가 콘텐츠를 번들로 제공할 수 있습니다:

![reference.md 및 forms.md와 같은 추가 참조 파일 번들링](/docs/images/agent-skills-bundling-content.png)

완전한 Skill 디렉토리 구조는 다음과 같습니다:

```
pdf/
├── SKILL.md              # 주요 지침 (트리거될 때 로드됨)
├── FORMS.md              # 양식 채우기 가이드 (필요시 로드됨)
├── reference.md          # API 참조 (필요시 로드됨)
├── examples.md           # 사용 예시 (필요시 로드됨)
└── scripts/
    ├── analyze_form.py   # 유틸리티 스크립트 (실행됨, 로드되지 않음)
    ├── fill_form.py      # 양식 채우기 스크립트
    └── validate.py       # 검증 스크립트
```

#### 패턴 1: 참조가 있는 상위 수준 가이드

````markdown
---
name: pdf-processing
description: PDF 파일에서 텍스트와 표를 추출하고, 양식을 채우고, 문서를 병합합니다. PDF 파일로 작업하거나 사용자가 PDF, 양식 또는 문서 추출을 언급할 때 사용합니다.
---

# PDF 처리

## 빠른 시작

pdfplumber로 텍스트 추출:
```python
import pdfplumber
with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
```

## 고급 기능

**양식 채우기**: 전체 가이드는 [FORMS.md](FORMS.md) 참조
**API 참조**: 모든 메서드는 [REFERENCE.md](REFERENCE.md) 참조
**예시**: 일반적인 패턴은 [EXAMPLES.md](EXAMPLES.md) 참조
````

Claude는 필요할 때만 FORMS.md, REFERENCE.md 또는 EXAMPLES.md를 로드합니다.

#### 패턴 2: 도메인별 조직

여러 도메인이 있는 Skill의 경우 도메인별로 콘텐츠를 조직하여 관련 없는 컨텍스트 로드를 방지합니다. 사용자가 매출 지표에 대해 물어보면 Claude는 매출 관련 스키마만 읽으면 되며, 재무나 마케팅 데이터는 필요하지 않습니다. 이렇게 하면 토큰 사용량이 낮게 유지되고 컨텍스트가 집중됩니다.

```
bigquery-skill/
├── SKILL.md (개요 및 탐색)
└── reference/
    ├── finance.md (수익, 청구 지표)
    ├── sales.md (기회, 파이프라인)
    ├── product.md (API 사용, 기능)
    └── marketing.md (캠페인, 어트리뷰션)
```

````markdown SKILL.md
# BigQuery 데이터 분석

## 사용 가능한 데이터셋

**Finance**: 수익, ARR, 청구 → [reference/finance.md](reference/finance.md) 참조
**Sales**: 기회, 파이프라인, 계정 → [reference/sales.md](reference/sales.md) 참조
**Product**: API 사용, 기능, 채택 → [reference/product.md](reference/product.md) 참조
**Marketing**: 캠페인, 어트리뷰션, 이메일 → [reference/marketing.md](reference/marketing.md) 참조

## 빠른 검색

grep을 사용하여 특정 지표 찾기:

```bash
grep -i "revenue" reference/finance.md
grep -i "pipeline" reference/sales.md
grep -i "api usage" reference/product.md
```
````

#### 패턴 3: 조건부 세부 정보

기본 콘텐츠를 표시하고 고급 콘텐츠로 링크:

```markdown
# DOCX 처리

## 문서 생성

새 문서에는 docx-js를 사용합니다. [DOCX-JS.md](DOCX-JS.md)를 참조하세요.

## 문서 편집

간단한 편집의 경우 XML을 직접 수정합니다.

**변경 추적**: [REDLINING.md](REDLINING.md) 참조
**OOXML 세부 정보**: [OOXML.md](OOXML.md) 참조
```

Claude는 사용자가 해당 기능이 필요할 때만 REDLINING.md 또는 OOXML.md를 읽습니다.

### 깊게 중첩된 참조 피하기

Claude는 다른 참조 파일에서 참조되는 파일을 부분적으로 읽을 수 있습니다. 중첩된 참조를 만나면 Claude는 전체 파일을 읽기보다 `head -100`과 같은 명령을 사용하여 콘텐츠를 미리 볼 수 있으며, 이는 불완전한 정보로 이어질 수 있습니다.

**SKILL.md에서 한 단계 깊이로 참조를 유지하세요**. 모든 참조 파일은 SKILL.md에서 직접 링크되어야 Claude가 필요할 때 전체 파일을 읽을 수 있습니다.

**나쁜 예: 너무 깊음**:
```markdown
# SKILL.md
[advanced.md](advanced.md) 참조...

# advanced.md
[details.md](details.md) 참조...

# details.md
실제 정보가 여기 있습니다...
```

**좋은 예: 한 단계 깊이**:
```markdown
# SKILL.md

**기본 사용법**: [SKILL.md의 지침]
**고급 기능**: [advanced.md](advanced.md) 참조
**API 참조**: [reference.md](reference.md) 참조
**예시**: [examples.md](examples.md) 참조
```

### 더 긴 참조 파일에 목차 구조화

100줄 이상의 참조 파일의 경우 상단에 목차를 포함하세요. 이렇게 하면 부분 읽기로 미리 볼 때도 Claude가 사용 가능한 정보의 전체 범위를 볼 수 있습니다.

**예시**:
```markdown
# API 참조

## 목차
- 인증 및 설정
- 핵심 메서드 (생성, 읽기, 업데이트, 삭제)
- 고급 기능 (배치 작업, 웹훅)
- 오류 처리 패턴
- 코드 예시

## 인증 및 설정
...

## 핵심 메서드
...
```

그러면 Claude는 전체 파일을 읽거나 필요에 따라 특정 섹션으로 이동할 수 있습니다.

이 파일 시스템 기반 아키텍처가 점진적 공개를 가능하게 하는 방법에 대한 자세한 내용은 아래 고급 섹션의 [런타임 환경](#런타임-환경) 섹션을 참조하세요.

## 워크플로우 및 피드백 루프

### 복잡한 작업에 워크플로우 사용

복잡한 작업을 명확하고 순차적인 단계로 나누세요. 특히 복잡한 워크플로우의 경우 Claude가 응답에 복사하고 진행 상황에 따라 체크할 수 있는 체크리스트를 제공하세요.

**예시 1: 연구 종합 워크플로우** (코드가 없는 Skill):

````markdown
## 연구 종합 워크플로우

이 체크리스트를 복사하고 진행 상황을 추적하세요:

```
연구 진행 상황:
- [ ] 1단계: 모든 소스 문서 읽기
- [ ] 2단계: 주요 주제 식별
- [ ] 3단계: 주장 상호 참조
- [ ] 4단계: 구조화된 요약 생성
- [ ] 5단계: 인용 확인
```

**1단계: 모든 소스 문서 읽기**

`sources/` 디렉토리의 각 문서를 검토합니다. 주요 논점과 뒷받침 증거를 기록합니다.

**2단계: 주요 주제 식별**

소스 전반의 패턴을 찾습니다. 어떤 주제가 반복적으로 나타나나요? 소스들이 어디서 동의하거나 동의하지 않나요?

**3단계: 주장 상호 참조**

각 주요 주장에 대해 소스 자료에 나타나는지 확인합니다. 어떤 소스가 각 포인트를 지원하는지 기록합니다.

**4단계: 구조화된 요약 생성**

주제별로 발견 사항을 정리합니다. 포함 내용:
- 주요 주장
- 소스의 뒷받침 증거
- 상충되는 관점 (있는 경우)

**5단계: 인용 확인**

모든 주장이 올바른 소스 문서를 참조하는지 확인합니다. 인용이 불완전하면 3단계로 돌아갑니다.
````

이 예시는 코드가 필요 없는 분석 작업에 워크플로우가 어떻게 적용되는지 보여줍니다. 체크리스트 패턴은 복잡한 다단계 프로세스에 적용됩니다.

**예시 2: PDF 양식 채우기 워크플로우** (코드가 있는 Skill):

````markdown
## PDF 양식 채우기 워크플로우

이 체크리스트를 복사하고 완료한 항목을 체크하세요:

```
작업 진행 상황:
- [ ] 1단계: 양식 분석 (analyze_form.py 실행)
- [ ] 2단계: 필드 매핑 생성 (fields.json 편집)
- [ ] 3단계: 매핑 검증 (validate_fields.py 실행)
- [ ] 4단계: 양식 채우기 (fill_form.py 실행)
- [ ] 5단계: 출력 확인 (verify_output.py 실행)
```

**1단계: 양식 분석**

실행: `python scripts/analyze_form.py input.pdf`

이는 양식 필드와 위치를 추출하여 `fields.json`에 저장합니다.

**2단계: 필드 매핑 생성**

각 필드에 대한 값을 추가하기 위해 `fields.json`을 편집합니다.

**3단계: 매핑 검증**

실행: `python scripts/validate_fields.py fields.json`

계속하기 전에 검증 오류를 수정합니다.

**4단계: 양식 채우기**

실행: `python scripts/fill_form.py input.pdf fields.json output.pdf`

**5단계: 출력 확인**

실행: `python scripts/verify_output.py output.pdf`

검증이 실패하면 2단계로 돌아갑니다.
````

명확한 단계는 Claude가 중요한 검증을 건너뛰는 것을 방지합니다. 체크리스트는 Claude와 사용자 모두가 다단계 워크플로우를 통해 진행 상황을 추적하는 데 도움이 됩니다.

### 피드백 루프 구현

**일반적인 패턴**: 검증기 실행 → 오류 수정 → 반복

이 패턴은 출력 품질을 크게 향상시킵니다.

**예시 1: 스타일 가이드 준수** (코드가 없는 Skill):

```markdown
## 콘텐츠 검토 프로세스

1. STYLE_GUIDE.md의 가이드라인을 따라 콘텐츠 초안 작성
2. 체크리스트와 대조하여 검토:
   - 용어 일관성 확인
   - 예시가 표준 형식을 따르는지 확인
   - 필요한 모든 섹션이 있는지 확인
3. 문제가 발견되면:
   - 각 문제를 특정 섹션 참조와 함께 기록
   - 콘텐츠 수정
   - 체크리스트를 다시 검토
4. 모든 요구 사항이 충족되면 진행
5. 문서 완료 및 저장
```

이는 스크립트 대신 참조 문서를 사용하는 검증 루프 패턴을 보여줍니다. "검증기"는 STYLE_GUIDE.md이며, Claude는 읽고 비교하여 확인을 수행합니다.

**예시 2: 문서 편집 프로세스** (코드가 있는 Skill):

```markdown
## 문서 편집 프로세스

1. `word/document.xml`에 편집 적용
2. **즉시 검증**: `python ooxml/scripts/validate.py unpacked_dir/`
3. 검증이 실패하면:
   - 오류 메시지를 주의 깊게 검토
   - XML의 문제 수정
   - 다시 검증 실행
4. **검증이 통과해야만 진행**
5. 재구축: `python ooxml/scripts/pack.py unpacked_dir/ output.docx`
6. 출력 문서 테스트
```

검증 루프는 오류를 조기에 포착합니다.

## 콘텐츠 가이드라인

### 시간에 민감한 정보 피하기

오래되어 유효하지 않게 될 정보는 포함하지 마세요:

**나쁜 예: 시간에 민감함** (유효하지 않게 됨):
```markdown
2025년 8월 이전에 이 작업을 수행하는 경우 이전 API를 사용하세요.
2025년 8월 이후에는 새 API를 사용하세요.
```

**좋은 예** ("이전 패턴" 섹션 사용):
```markdown
## 현재 방법

v2 API 엔드포인트 사용: `api.example.com/v2/messages`

## 이전 패턴

<details>
<summary>레거시 v1 API (2025-08 폐기됨)</summary>

v1 API 사용: `api.example.com/v1/messages`

이 엔드포인트는 더 이상 지원되지 않습니다.
</details>
```

이전 패턴 섹션은 주요 콘텐츠를 어지럽히지 않으면서 역사적 컨텍스트를 제공합니다.

### 일관된 용어 사용

하나의 용어를 선택하고 Skill 전체에서 사용하세요:

**좋음 - 일관성**:
- 항상 "API 엔드포인트"
- 항상 "필드"
- 항상 "추출"

**나쁨 - 일관성 없음**:
- "API 엔드포인트", "URL", "API 경로", "경로" 혼용
- "필드", "상자", "요소", "컨트롤" 혼용
- "추출", "가져오기", "얻기", "검색" 혼용

일관성은 Claude가 지침을 이해하고 따르는 데 도움이 됩니다.

## 일반적인 패턴

### 템플릿 패턴

출력 형식에 대한 템플릿을 제공합니다. 필요에 맞게 엄격성 수준을 조정합니다.

**엄격한 요구 사항의 경우** (API 응답이나 데이터 형식처럼):

````markdown
## 보고서 구조

항상 이 정확한 템플릿 구조를 사용하세요:

```markdown
# [분석 제목]

## 요약
[주요 발견 사항에 대한 한 단락 개요]

## 주요 발견 사항
- 뒷받침 데이터가 있는 발견 사항 1
- 뒷받침 데이터가 있는 발견 사항 2
- 뒷받침 데이터가 있는 발견 사항 3

## 권장 사항
1. 구체적이고 실행 가능한 권장 사항
2. 구체적이고 실행 가능한 권장 사항
```
````

**유연한 가이드의 경우** (적응이 유용할 때):

````markdown
## 보고서 구조

다음은 합리적인 기본 형식이지만 분석에 따라 최선의 판단을 사용하세요:

```markdown
# [분석 제목]

## 요약
[개요]

## 주요 발견 사항
[발견한 내용에 따라 섹션 조정]

## 권장 사항
[특정 컨텍스트에 맞게 조정]
```

특정 분석 유형에 따라 필요에 따라 섹션을 조정하세요.
````

### 예시 패턴

출력 품질이 예시를 보는 것에 달려 있는 Skill의 경우 일반 프롬프팅과 마찬가지로 입력/출력 쌍을 제공하세요:

````markdown
## 커밋 메시지 형식

다음 예시를 따라 커밋 메시지를 생성하세요:

**예시 1:**
입력: JWT 토큰을 사용한 사용자 인증 추가
출력:
```
feat(auth): JWT 기반 인증 구현

로그인 엔드포인트 및 토큰 검증 미들웨어 추가
```

**예시 2:**
입력: 보고서에서 날짜가 잘못 표시되는 버그 수정
출력:
```
fix(reports): 시간대 변환에서 날짜 형식 수정

보고서 생성 전반에 걸쳐 UTC 타임스탬프를 일관되게 사용
```

**예시 3:**
입력: 종속성 업데이트 및 오류 처리 리팩토링
출력:
```
chore: 종속성 업데이트 및 오류 처리 리팩토링

- lodash를 4.17.21로 업그레이드
- 엔드포인트 전반에 걸쳐 오류 응답 형식 표준화
```

이 스타일을 따르세요: type(scope): 간단한 설명, 그 다음 상세한 설명.
````

예시는 Claude가 설명만으로보다 원하는 스타일과 세부 수준을 더 명확하게 이해하는 데 도움이 됩니다.

### 조건부 워크플로우 패턴

의사 결정 지점을 통해 Claude를 안내합니다:

```markdown
## 문서 수정 워크플로우

1. 수정 유형 결정:

   **새 콘텐츠 생성?** → 아래 "생성 워크플로우" 따르기
   **기존 콘텐츠 편집?** → 아래 "편집 워크플로우" 따르기

2. 생성 워크플로우:
   - docx-js 라이브러리 사용
   - 처음부터 문서 구축
   - .docx 형식으로 내보내기

3. 편집 워크플로우:
   - 기존 문서 압축 해제
   - XML 직접 수정
   - 각 변경 후 검증
   - 완료되면 재압축
```


> 워크플로우가 많은 단계로 크거나 복잡해지면 별도의 파일로 푸시하고 해당 작업에 따라 적절한 파일을 읽도록 Claude에게 지시하는 것을 고려하세요.


## 평가 및 반복

### 평가를 먼저 구축

**광범위한 문서를 작성하기 전에 평가를 생성하세요.** 이렇게 하면 Skill이 상상한 문제가 아닌 실제 문제를 해결합니다.

**평가 주도 개발:**
1. **격차 식별**: Skill 없이 대표적인 작업에서 Claude를 실행합니다. 특정 실패 또는 누락된 컨텍스트를 문서화합니다
2. **평가 생성**: 이러한 격차를 테스트하는 세 가지 시나리오를 구축합니다
3. **기준선 설정**: Skill 없이 Claude의 성능을 측정합니다
4. **최소 지침 작성**: 격차를 해결하고 평가를 통과하기에 충분한 콘텐츠만 생성합니다
5. **반복**: 평가를 실행하고 기준선과 비교하여 개선합니다

이 접근 방식은 실현되지 않을 수 있는 요구 사항을 예상하는 대신 실제 문제를 해결하도록 보장합니다.

**평가 구조**:
```json
{
  "skills": ["pdf-processing"],
  "query": "이 PDF 파일에서 모든 텍스트를 추출하여 output.txt에 저장하세요",
  "files": ["test-files/document.pdf"],
  "expected_behavior": [
    "적절한 PDF 처리 라이브러리 또는 명령줄 도구를 사용하여 PDF 파일을 성공적으로 읽습니다",
    "페이지를 놓치지 않고 문서의 모든 페이지에서 텍스트 콘텐츠를 추출합니다",
    "추출된 텍스트를 명확하고 읽기 쉬운 형식으로 output.txt라는 파일에 저장합니다"
  ]
}
```


> 이 예시는 간단한 테스트 루브릭이 있는 데이터 기반 평가를 보여줍니다. 현재 이러한 평가를 실행하는 내장 방법은 제공하지 않습니다. 사용자는 자체 평가 시스템을 만들 수 있습니다. 평가는 Skill 효과를 측정하는 진실의 원천입니다.


### Claude와 함께 반복적으로 Skill 개발

가장 효과적인 Skill 개발 프로세스는 Claude 자체를 포함합니다. 하나의 Claude 인스턴스("Claude A")와 작업하여 다른 인스턴스("Claude B")가 사용할 Skill을 만듭니다. Claude A는 지침을 설계하고 다듬는 데 도움을 주고, Claude B는 실제 작업에서 테스트합니다. 이는 Claude 모델이 효과적인 에이전트 지침을 작성하는 방법과 에이전트에 필요한 정보를 모두 이해하기 때문에 작동합니다.

**새 Skill 만들기:**

1. **Skill 없이 작업 완료**: Claude A와 일반 프롬프팅을 사용하여 문제를 해결합니다. 작업하면서 자연스럽게 컨텍스트를 제공하고, 선호도를 설명하고, 절차적 지식을 공유합니다. 반복적으로 제공하는 정보에 주목하세요.

2. **재사용 가능한 패턴 식별**: 작업을 완료한 후 유사한 향후 작업에 유용할 제공한 컨텍스트를 식별합니다.

   **예시**: BigQuery 분석을 진행했다면 테이블 이름, 필드 정의, 필터링 규칙(예: "항상 테스트 계정 제외"), 일반적인 쿼리 패턴을 제공했을 수 있습니다.

3. **Claude A에게 Skill 생성 요청**: "방금 사용한 이 BigQuery 분석 패턴을 캡처하는 Skill을 만들어주세요. 테이블 스키마, 명명 규칙, 테스트 계정 필터링 규칙을 포함하세요."

   
> Claude 모델은 Skill 형식과 구조를 기본적으로 이해합니다. Skill 생성을 위해 Claude에게 도움을 요청하기 위해 특별한 시스템 프롬프트나 "Skill 작성" Skill이 필요하지 않습니다. 단순히 Claude에게 Skill을 만들도록 요청하면 적절한 frontmatter와 본문 콘텐츠가 있는 제대로 구조화된 SKILL.md 콘텐츠를 생성합니다.


4. **간결성 검토**: Claude A가 불필요한 설명을 추가하지 않았는지 확인합니다. 질문하세요: "승률이 무엇을 의미하는지에 대한 설명을 제거하세요 - Claude는 이미 그것을 알고 있습니다."

5. **정보 아키텍처 개선**: Claude A에게 콘텐츠를 더 효과적으로 구성하도록 요청합니다. 예를 들어: "테이블 스키마를 별도의 참조 파일로 구성하세요. 나중에 더 많은 테이블을 추가할 수 있습니다."

6. **유사한 작업에서 테스트**: Skill이 로드된 Claude B(새로운 인스턴스)와 관련 사용 사례에서 Skill을 사용합니다. Claude B가 올바른 정보를 찾고, 규칙을 올바르게 적용하고, 작업을 성공적으로 처리하는지 관찰합니다.

7. **관찰에 기반한 반복**: Claude B가 어려움을 겪거나 무언가를 놓친 경우 구체적인 내용과 함께 Claude A로 돌아갑니다: "Claude가 이 Skill을 사용할 때 Q4에 대한 날짜 필터링을 잊었습니다. 날짜 필터링 패턴에 대한 섹션을 추가해야 할까요?"

**기존 Skill 반복:**

Skill을 개선할 때도 동일한 계층적 패턴이 계속됩니다. 다음 간에 번갈아 가며:
- **Claude A와 작업** (Skill을 다듬는 데 도움을 주는 전문가)
- **Claude B로 테스트** (실제 작업을 수행하기 위해 Skill을 사용하는 에이전트)
- **Claude B의 동작 관찰** 및 통찰력을 Claude A로 가져오기

1. **실제 워크플로우에서 Skill 사용**: Claude B(Skill이 로드됨)에게 테스트 시나리오가 아닌 실제 작업을 제공합니다

2. **Claude B의 동작 관찰**: 어려움을 겪거나 성공하거나 예상치 못한 선택을 하는 지점을 기록합니다

   **예시 관찰**: "Claude B에게 지역별 매출 보고서를 요청했을 때 쿼리를 작성했지만 Skill에서 이 규칙을 언급했음에도 불구하고 테스트 계정을 필터링하는 것을 잊었습니다."

3. **개선을 위해 Claude A로 돌아가기**: 현재 SKILL.md를 공유하고 관찰한 내용을 설명합니다. 질문하세요: "지역 보고서를 요청했을 때 Claude B가 테스트 계정을 필터링하는 것을 잊었습니다. Skill이 필터링을 언급하지만 충분히 눈에 띄지 않는 것 같습니다?"

4. **Claude A의 제안 검토**: Claude A는 규칙을 더 눈에 띄게 만들기 위해 재구성하거나 "항상 필터" 대신 "필터링해야 함"과 같은 더 강한 언어를 사용하거나 워크플로우 섹션을 재구성하도록 제안할 수 있습니다.

5. **변경 사항 적용 및 테스트**: Claude A의 개선 사항으로 Skill을 업데이트한 다음 유사한 요청에서 Claude B로 다시 테스트합니다

6. **사용에 따라 반복**: 새로운 시나리오를 만날 때 이 관찰-개선-테스트 주기를 계속합니다. 각 반복은 가정이 아닌 실제 에이전트 동작을 기반으로 Skill을 개선합니다.

**팀 피드백 수집:**

1. 팀원과 Skill을 공유하고 사용을 관찰합니다
2. 질문하세요: Skill이 예상대로 활성화되나요? 지침이 명확한가요? 무엇이 누락되었나요?
3. 자신의 사용 패턴에서 맹점을 해결하기 위해 피드백을 통합합니다

**이 접근 방식이 작동하는 이유**: Claude A는 에이전트 요구 사항을 이해하고, 사용자는 도메인 전문 지식을 제공하고, Claude B는 실제 사용을 통해 격차를 드러내고, 반복적인 개선은 가정이 아닌 관찰된 동작을 기반으로 Skill을 개선합니다.

### Claude가 Skill을 탐색하는 방법 관찰

Skill을 반복할 때 Claude가 실제로 어떻게 사용하는지 주의를 기울이세요. 다음을 주시하세요:

- **예상치 못한 탐색 경로**: Claude가 예상하지 못한 순서로 파일을 읽나요? 이는 구조가 생각만큼 직관적이지 않다는 것을 나타낼 수 있습니다
- **놓친 연결**: Claude가 중요한 파일에 대한 참조를 따르지 못하나요? 링크가 더 명시적이거나 눈에 띄어야 할 수 있습니다
- **특정 섹션에 대한 과도한 의존**: Claude가 동일한 파일을 반복적으로 읽으면 해당 콘텐츠가 대신 주요 SKILL.md에 있어야 하는지 고려하세요
- **무시된 콘텐츠**: Claude가 번들 파일에 접근하지 않으면 불필요하거나 주요 지침에서 제대로 신호를 보내지 못한 것일 수 있습니다

가정이 아닌 이러한 관찰을 기반으로 반복하세요. Skill 메타데이터의 'name'과 'description'은 특히 중요합니다. Claude는 현재 작업에 응답하여 Skill을 트리거할지 여부를 결정할 때 이를 사용합니다. Skill이 무엇을 하는지, 언제 사용해야 하는지 명확하게 설명해야 합니다.

## 피해야 할 안티패턴

### Windows 스타일 경로 피하기

Windows에서도 파일 경로에 항상 슬래시를 사용하세요:

- ✓ **좋음**: `scripts/helper.py`, `reference/guide.md`
- ✗ **피해야 함**: `scripts\helper.py`, `reference\guide.md`

Unix 스타일 경로는 모든 플랫폼에서 작동하지만 Windows 스타일 경로는 Unix 시스템에서 오류를 일으킵니다.

### 너무 많은 옵션 제공 피하기

필요하지 않으면 여러 접근 방식을 제시하지 마세요:

````markdown
**나쁜 예: 선택지가 너무 많음** (혼란스러움):
"pypdf, pdfplumber, PyMuPDF, pdf2image 등을 사용할 수 있습니다..."

**좋은 예: 기본값 제공** (탈출구와 함께):
"텍스트 추출에는 pdfplumber를 사용하세요:
```python
import pdfplumber
```

OCR이 필요한 스캔된 PDF의 경우 대신 pdf2image와 pytesseract를 사용하세요."
````

## 고급: 실행 가능한 코드가 있는 Skill

아래 섹션은 실행 가능한 스크립트가 포함된 Skill에 중점을 둡니다. Skill이 마크다운 지침만 사용하는 경우 [효과적인 Skill을 위한 체크리스트](#효과적인-skill을-위한-체크리스트)로 건너뛰세요.

### 해결하고, 회피하지 마세요

Skill용 스크립트를 작성할 때 Claude에게 넘기기보다 오류 조건을 처리하세요.

**좋은 예: 오류를 명시적으로 처리**:
```python
def process_file(path):
    """파일이 존재하지 않으면 생성하여 파일을 처리합니다."""
    try:
        with open(path) as f:
            return f.read()
    except FileNotFoundError:
        # 실패하는 대신 기본 콘텐츠로 파일 생성
        print(f"파일 {path}을(를) 찾을 수 없습니다. 기본값 생성 중")
        with open(path, 'w') as f:
            f.write('')
        return ''
    except PermissionError:
        # 실패하는 대신 대안 제공
        print(f"{path}에 접근할 수 없습니다. 기본값 사용 중")
        return ''
```

**나쁜 예: Claude에게 넘기기**:
```python
def process_file(path):
    # 그냥 실패하고 Claude가 알아내도록 함
    return open(path).read()
```

구성 매개변수도 "voodoo 상수"(Ousterhout의 법칙)를 피하기 위해 정당화되고 문서화되어야 합니다. 올바른 값을 모르면 Claude가 어떻게 결정할까요?

**좋은 예: 자체 문서화**:
```python
# HTTP 요청은 일반적으로 30초 이내에 완료됩니다
# 더 긴 타임아웃은 느린 연결을 고려합니다
REQUEST_TIMEOUT = 30

# 세 번의 재시도는 안정성과 속도의 균형을 맞춥니다
# 대부분의 간헐적 실패는 두 번째 재시도까지 해결됩니다
MAX_RETRIES = 3
```

**나쁜 예: 마법의 숫자**:
```python
TIMEOUT = 47  # 왜 47?
RETRIES = 5   # 왜 5?
```

### 유틸리티 스크립트 제공

Claude가 스크립트를 작성할 수 있더라도 미리 만든 스크립트는 장점을 제공합니다:

**유틸리티 스크립트의 이점**:
- 생성된 코드보다 더 안정적
- 토큰 절약 (컨텍스트에 코드를 포함할 필요 없음)
- 시간 절약 (코드 생성 필요 없음)
- 사용 전반에 걸쳐 일관성 보장

![지침 파일과 함께 실행 가능한 스크립트 번들링](/docs/images/agent-skills-executable-scripts.png)

위 다이어그램은 실행 가능한 스크립트가 지침 파일과 함께 작동하는 방법을 보여줍니다. 지침 파일(forms.md)이 스크립트를 참조하고, Claude는 해당 내용을 컨텍스트에 로드하지 않고도 실행할 수 있습니다.

**중요한 구별**: Claude가 다음 중 무엇을 해야 하는지 지침에서 명확히 하세요:
- **스크립트 실행** (가장 일반적): "`analyze_form.py`를 실행하여 필드를 추출하세요"
- **참조로 읽기** (복잡한 로직의 경우): "필드 추출 알고리즘은 `analyze_form.py`를 참조하세요"

대부분의 유틸리티 스크립트의 경우 더 안정적이고 효율적이므로 실행이 선호됩니다. 스크립트 실행이 작동하는 방법에 대한 자세한 내용은 아래의 [런타임 환경](#런타임-환경) 섹션을 참조하세요.

**예시**:
````markdown
## 유틸리티 스크립트

**analyze_form.py**: PDF에서 모든 양식 필드 추출

```bash
python scripts/analyze_form.py input.pdf > fields.json
```

출력 형식:
```json
{
  "field_name": {"type": "text", "x": 100, "y": 200},
  "signature": {"type": "sig", "x": 150, "y": 500}
}
```

**validate_boxes.py**: 겹치는 경계 상자 확인

```bash
python scripts/validate_boxes.py fields.json
# 반환: "OK" 또는 충돌 목록
```

**fill_form.py**: PDF에 필드 값 적용

```bash
python scripts/fill_form.py input.pdf fields.json output.pdf
```
````

### 시각적 분석 사용

입력이 이미지로 렌더링될 수 있는 경우 Claude가 분석하도록 하세요:

````markdown
## 양식 레이아웃 분석

1. PDF를 이미지로 변환:
   ```bash
   python scripts/pdf_to_images.py form.pdf
   ```

2. 각 페이지 이미지를 분석하여 양식 필드 식별
3. Claude는 필드 위치와 유형을 시각적으로 볼 수 있습니다
````


> 이 예시에서는 `pdf_to_images.py` 스크립트를 작성해야 합니다.


Claude의 비전 기능은 레이아웃과 구조를 이해하는 데 도움이 됩니다.

### 검증 가능한 중간 출력 생성

Claude가 복잡하고 개방형 작업을 수행할 때 실수를 할 수 있습니다. "계획-검증-실행" 패턴은 Claude가 먼저 구조화된 형식으로 계획을 만든 다음 실행하기 전에 스크립트로 해당 계획을 검증하여 조기에 오류를 포착합니다.

**예시**: Claude에게 스프레드시트를 기반으로 PDF의 50개 양식 필드를 업데이트하도록 요청한다고 상상해보세요. 검증 없이 Claude는 존재하지 않는 필드를 참조하거나, 충돌하는 값을 생성하거나, 필수 필드를 놓치거나, 업데이트를 잘못 적용할 수 있습니다.

**해결책**: 위에 표시된 워크플로우 패턴(PDF 양식 채우기)을 사용하되 변경 사항을 적용하기 전에 검증되는 중간 `changes.json` 파일을 추가합니다. 워크플로우는 다음과 같습니다: 분석 → **계획 파일 생성** → **계획 검증** → 실행 → 확인.

**이 패턴이 작동하는 이유:**
- **조기에 오류 포착**: 검증은 변경 사항이 적용되기 전에 문제를 찾습니다
- **기계적으로 검증 가능**: 스크립트는 객관적인 검증을 제공합니다
- **가역적 계획**: Claude는 원본을 건드리지 않고 계획을 반복할 수 있습니다
- **명확한 디버깅**: 오류 메시지가 특정 문제를 가리킵니다

**사용 시기**: 배치 작업, 파괴적 변경, 복잡한 검증 규칙, 높은 위험 작업.

**구현 팁**: "필드 'signature_date'를 찾을 수 없습니다. 사용 가능한 필드: customer_name, order_total, signature_date_signed"와 같은 구체적인 오류 메시지를 제공하는 검증 스크립트를 상세하게 만들어 Claude가 문제를 수정하는 데 도움을 줍니다.

### 패키지 종속성

Skill은 플랫폼별 제한이 있는 코드 실행 환경에서 실행됩니다:

- **claude.ai**: npm 및 PyPI에서 패키지를 설치하고 GitHub 리포지토리에서 가져올 수 있습니다
- **Anthropic API**: 네트워크 액세스가 없고 런타임 패키지 설치가 없습니다

SKILL.md에 필요한 패키지를 나열하고 [코드 실행 도구 문서](../03-tools/05-code-execution-tool.md)에서 사용 가능한지 확인하세요.

### 런타임 환경

Skill은 파일 시스템 액세스, bash 명령 및 코드 실행 기능이 있는 코드 실행 환경에서 실행됩니다. 이 아키텍처의 개념적 설명은 개요의 [The Skills architecture](../04-agent-skills/01-overview.md)를 참조하세요.

**작성에 미치는 영향:**

**Claude가 Skill에 액세스하는 방법:**

1. **메타데이터 사전 로드**: 시작 시 모든 Skill의 YAML frontmatter의 name과 description이 시스템 프롬프트에 로드됩니다
2. **주문형 파일 읽기**: Claude는 bash Read 도구를 사용하여 필요할 때 파일 시스템에서 SKILL.md 및 기타 파일에 액세스합니다
3. **효율적으로 실행되는 스크립트**: 유틸리티 스크립트는 전체 내용을 컨텍스트에 로드하지 않고도 bash를 통해 실행될 수 있습니다. 스크립트의 출력만 토큰을 소비합니다
4. **대형 파일에 대한 컨텍스트 패널티 없음**: 참조 파일, 데이터 또는 문서는 실제로 읽기 전까지 컨텍스트 토큰을 소비하지 않습니다

- **파일 경로가 중요합니다**: Claude는 파일 시스템처럼 Skill 디렉토리를 탐색합니다. 백슬래시가 아닌 슬래시(`reference/guide.md`)를 사용하세요
- **파일 이름을 설명적으로 지정**: 콘텐츠를 나타내는 이름을 사용하세요: `form_validation_rules.md`, `doc2.md`가 아님
- **발견을 위해 구성**: 도메인 또는 기능별로 디렉토리 구조화
  - 좋음: `reference/finance.md`, `reference/sales.md`
  - 나쁨: `docs/file1.md`, `docs/file2.md`
- **포괄적인 리소스 번들**: 완전한 API 문서, 광범위한 예시, 대용량 데이터셋 포함; 액세스할 때까지 컨텍스트 패널티 없음
- **결정론적 작업에는 스크립트를 선호**: Claude에게 검증 코드를 생성하도록 요청하기보다 `validate_form.py`를 작성하세요
- **실행 의도를 명확하게 하세요**:
  - "`analyze_form.py`를 실행하여 필드를 추출하세요" (실행)
  - "추출 알고리즘은 `analyze_form.py`를 참조하세요" (참조로 읽기)
- **파일 액세스 패턴 테스트**: 실제 요청으로 테스트하여 Claude가 디렉토리 구조를 탐색할 수 있는지 확인하세요

**예시:**

```
bigquery-skill/
├── SKILL.md (개요, 참조 파일 가리킴)
└── reference/
    ├── finance.md (수익 지표)
    ├── sales.md (파이프라인 데이터)
    └── product.md (사용 분석)
```

사용자가 수익에 대해 물어보면 Claude는 SKILL.md를 읽고 `reference/finance.md`에 대한 참조를 확인하고 bash를 호출하여 해당 파일만 읽습니다. sales.md와 product.md 파일은 파일 시스템에 남아 있으며 필요할 때까지 0개의 컨텍스트 토큰을 소비합니다. 이 파일 시스템 기반 모델이 점진적 공개를 가능하게 하는 것입니다. Claude는 각 작업에 필요한 것을 정확하게 탐색하고 선택적으로 로드할 수 있습니다.

기술 아키텍처에 대한 전체 세부 정보는 Skills 개요의 [How Skills work](../04-agent-skills/01-overview.md)를 참조하세요.

### MCP 도구 참조

Skill이 MCP(Model Context Protocol) 도구를 사용하는 경우 "도구를 찾을 수 없음" 오류를 방지하기 위해 항상 정규화된 도구 이름을 사용하세요.

**형식**: `ServerName:tool_name`

**예시**:
```markdown
BigQuery:bigquery_schema 도구를 사용하여 테이블 스키마를 검색하세요.
GitHub:create_issue 도구를 사용하여 이슈를 생성하세요.
```

여기서:
- `BigQuery`와 `GitHub`는 MCP 서버 이름입니다
- `bigquery_schema`와 `create_issue`는 해당 서버 내의 도구 이름입니다

서버 접두사가 없으면 특히 여러 MCP 서버를 사용할 수 있을 때 Claude가 도구를 찾지 못할 수 있습니다.

### 도구가 설치되어 있다고 가정하지 마세요

패키지를 사용할 수 있다고 가정하지 마세요:

````markdown
**나쁜 예: 설치를 가정**:
"pdf 라이브러리를 사용하여 파일을 처리하세요."

**좋은 예: 종속성에 대해 명시적**:
"필요한 패키지 설치: `pip install pypdf`

그런 다음 사용:
```python
from pypdf import PdfReader
reader = PdfReader("file.pdf")
```"
````

## 기술적 참고사항

### YAML frontmatter 요구 사항

SKILL.md frontmatter는 특정 검증 규칙이 있는 `name`과 `description` 필드가 필요합니다:
- `name`: 최대 64자, 소문자/숫자/하이픈만, XML 태그 없음, 예약어 없음
- `description`: 최대 1024자, 비어 있지 않음, XML 태그 없음

전체 구조에 대한 자세한 내용은 [Skills 개요](../04-agent-skills/01-overview.md)를 참조하세요.

### 토큰 예산

최적의 성능을 위해 SKILL.md 본문을 500줄 이하로 유지하세요. 콘텐츠가 이를 초과하면 앞에서 설명한 점진적 공개 패턴을 사용하여 별도의 파일로 분할하세요. 아키텍처 세부 정보는 [Skills 개요](../04-agent-skills/01-overview.md)를 참조하세요.

## 효과적인 Skill을 위한 체크리스트

Skill을 공유하기 전에 확인하세요:

### 핵심 품질
- [ ] 설명이 구체적이고 핵심 용어를 포함
- [ ] 설명에 Skill이 무엇을 하는지와 언제 사용하는지 모두 포함
- [ ] SKILL.md 본문이 500줄 이하
- [ ] 추가 세부 정보가 별도 파일에 있음 (필요한 경우)
- [ ] 시간에 민감한 정보 없음 (또는 "이전 패턴" 섹션에 있음)
- [ ] 전체적으로 일관된 용어 사용
- [ ] 예시가 구체적이고 추상적이지 않음
- [ ] 파일 참조가 한 단계 깊이
- [ ] 점진적 공개를 적절히 사용
- [ ] 워크플로우에 명확한 단계가 있음

### 코드 및 스크립트
- [ ] 스크립트가 Claude에게 넘기기보다 문제를 해결
- [ ] 오류 처리가 명시적이고 도움이 됨
- [ ] "voodoo 상수" 없음 (모든 값이 정당화됨)
- [ ] 필요한 패키지가 지침에 나열되고 사용 가능한 것으로 확인됨
- [ ] 스크립트에 명확한 문서가 있음
- [ ] Windows 스타일 경로 없음 (모두 슬래시)
- [ ] 중요한 작업에 대한 검증/확인 단계
- [ ] 품질이 중요한 작업에 피드백 루프 포함

### 테스트
- [ ] 최소 세 개의 평가 생성
- [ ] Haiku, Sonnet, Opus로 테스트
- [ ] 실제 사용 시나리오로 테스트
- [ ] 팀 피드백 통합 (해당하는 경우)

## 다음 단계


  
> 첫 번째 Skill 만들기

  
> Claude Code에서 Skills 생성 및 관리

  
> TypeScript 및 Python에서 프로그래밍 방식으로 Skills 사용

  
> 프로그래밍 방식으로 Skills 업로드 및 사용


