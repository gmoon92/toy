# Naming Strategy for Event-Driven Components

_이 문서는 이벤트 기반 아키텍처에서 자주 사용되는 `Listener`, `Processor`, `Handler`의 **역할과 사용 조건을 명확히 구분하고**, 일관된 명명 규칙을 수립하기 위한 가이드다._

이벤트 기반(event-driven) 시스템을 설계할 때 `Listener`, `Processor`, `Handler`는 비슷하게 보일 수 있으나, **역할과 트리거 방식에 따라 명확히 구분**해야 한다. 이 문서는
세 컴포넌트의 성격을 정의하고, **일관된 네이밍 전략** 수립을 통해 유지보수성과 가독성을 높이는 것을 목표로 한다.

## 컴포넌트 유형별 정의 및 구분

| 유형            | 역할                      | 트리거/호출 방식          | 대표 사용 사례               |
|---------------|-------------------------|--------------------|------------------------|
| **Listener**  | 이벤트 감지 후 후속 동작 수행       | 이벤트 기반 (수동 호출)     | 이벤트 발생 후 로깅, 알림 등 후처리  |
| **Processor** | 데이터 처리 (정제, 검증, 변환 등)   | 명령형 흐름에서 능동 호출     | 입력 데이터 정제, 유효성 검사      |
| **Handler**   | 목적 지향 처리 (예외, 분기, 실패 등) | 명시적 호출 또는 조건 기반 호출 | 실패 처리, 재시도, 분기 로직 처리 등 |

- **Listener**: 외부 이벤트에 "반응"하는 수동형
- **Processor**: 데이터를 "정제·변환"하는 중간 처리자
- **Handler**: 예외/분기 등 특정 목적에 따라 "처리"하는 단위

## 컴포넌트 유형별 가이드

이 전략은 이벤트 기반 시스템 외에도, 단순한 명령형 흐름에서도 활용 가능합니다.

- `Listener`는 이벤트 발생 시 특정 처리를 수행하기 위해 등록된 구독자 역할의 컴포넌트
- `Processor`는 데이터 중심의 직렬 흐름에서 사용되며, 반복적으로 재사용 가능성을 가짐
- `Handler`는 예외, 실패, 조건 분기 등 **컨텍스트 기반** 처리 책임을 분리할 때 적합하다.

> 예: 웹 요청 처리 과정에서 Processor를 통해 데이터 정제 후 Handler로 분기 처리 등

### Listener

- **정의**: 이벤트가 발생했을 때 자동으로 반응하는 수동적 컴포넌트
- **적용 조건**:
    - 이벤트 발행/구독 구조 (ex. Spring Event, Kafka Consumer 등)
    - 후속 처리를 외부에서 수행하도록 위임하고 싶을 때
- **사용 예시**:
    - `UserSignupListener`: 회원 가입 이벤트 발생 시 환영 이메일 발송
    - `SystemShutdownListener`: 시스템 종료 이벤트 후 리소스 정리

### Processor

- **정의**: 데이터를 정제, 검증, 변환 등 **직접 처리**하는 능동적 컴포넌트
- **적용 조건**:
    - 파이프라인 구성 시 처리 파이프라인의 중간 컴포넌트로 활용
    - 호출자가 명확히 실행 흐름을 제어하는 구조
- **사용 예시**:
    - `FormDataProcessor`: 폼 입력 데이터를 검증하고 구조화
    - `PaymentValidationProcessor`: 결제 요청 데이터 검증

### Handler

- **정의**: 예외, 실패, 조건 분기 등 특정 목적에 따른 처리를 담당하는 컴포넌트
- **적용 조건**:
    - 다양한 입력 또는 실패 케이스에 따라 분기 처리 필요
    - 후속 액션이 명확히 책임 단위로 분리되어야 할 때
- **사용 예시**:
    - `ValidationErrorHandler`: 유효성 검사 실패 시 로깅 및 큐 적재
    - `RetryQueueHandler`: 외부 API 호출 실패 시 재시도 처리

## 이름 적용 예시

| 기능                 | 컴포넌트 이름 예시               |
|--------------------|--------------------------|
| 이벤트 구독 후 알림        | `UserSignupListener`     |
| 데이터 정제·검증          | `FormDataProcessor`      |
| 유효성 실패 후 로깅        | `ValidationErrorHandler` |
| 외부 API 실패 시 재시도 처리 | `ApiRetryHandler`        |

## 적용 대상 시스템

이 네이밍 전략은 다음과 같은 구조에서 보편적으로 활용 가능하다:

- 이벤트 기반 백엔드 애플리케이션
- 메시지 큐 기반 시스템 (Kafka, RabbitMQ 등)
- 파이프라인/배치 기반 데이터 처리 시스템
- 다양한 입력/출력/예외 상황이 있는 처리 흐름 설계

| 유형        | 적용에 적합한 구조 설명                          |
|-----------|----------------------------------------|
| Listener  | 이벤트 중심 아키텍처, 콜백 기반 트리거 구성이 필요한 경우      |
| Processor | 명령형 흐름, 데이터 파이프라인 등에서 처리 단계 분리가 필요한 경우 |
| Handler   | 예외/실패/분기 로직 처리가 명확히 구분되어야 할 경우         |

## 체크리스트

- 역할이 명확한가? (객체 생성인지, 흐름 제어인지, 변환인지)
- 고유 책임이 존재하는가? (하나의 목적에 집중?)
- 전략/정책/규칙과 관련이 있다면 구분 기준은 명확한가?
- 모듈/도메인 컨텍스트를 중복해서 표현하고 있진 않은가?
- 테스트 가능성과 대체 가능성(플러그인 구조)을 고려했는가?

## 마무리

이 명명 전략은 이벤트 중심 애플리케이션뿐만 아니라, 데이터 파이프라인, 메시지 큐 기반 아키텍처, 백엔드 서비스 처리 흐름 등 다양한 구조에 보편적으로 적용할 수 있다.

적용 대상 예:

- 이벤트 기반 백엔드 애플리케이션
- 메시지 큐 기반 구조 (Kafka, RabbitMQ 등)
- 파이프라인 또는 워크플로우 기반 처리 시스템
- 다양한 입력/출력/예외 상황을 다루는 모듈 설계

| 유형        | 적합한 상황 설명                                |
|-----------|------------------------------------------|
| Listener  | 이벤트 중심, 콜백 방식 구성일 때                      |
| Processor | 데이터 주도(data-driven) 구조, 정제/검증/변환이 필요한 경우 |
| Handler   | 다양한 입력 또는 목적성 처리(예외, 분기, 실패 등)가 필요한 경우   |

이 전략을 코드 전반에 일관되게 적용하면, **가독성 향상뿐 아니라 컴포넌트 책임 분리에도 도움이 된다.**

---

### [더 알아보기](naming-strategy-for-event-driven-components-deep-dive.md)

본 문서에서는 `Listener`, `Processor`, `Handler`의 명명 전략에 집중했지만,
애플리케이션 전반의 일관된 네이밍 전략을 위해 다음 영역도 확장 가능합니다:

- `Factory`, `Mapper`, `Resolver`, `Strategy` 등의 일반 역할 기반 명명 규칙
- `Coordinator`, `Executor` 등 작업 조율/실행 중심 네이밍
- `Policy`, `Strategy`, `Resolver` 등 도메인 특화 명명 규칙
- `anti-pattern` 사례 정리

이러한 확장은 [V2 – 확장 네이밍 전략 가이드](naming-strategy-for-event-driven-components-deep-dive.md) 에서 자세히 다루고 있습니다.
